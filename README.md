# Задание 1
## Задача 1
### Текст задачи
Создайте сущность Точка, расположенную на двумерной плоскости, которая описывается: 
• Координата Х: число
 • Координата Y: число
 • Может возвращать текстовое представление вида “{X;Y}” 
Необходимо создать три точки с разными координатами и вывести на экран их текстовое представление.
### Алгоритм решения
Создаем два приватных поля, обозначающие координаты точек -  x и y. Прописываем для них свойства: геттеры (getX и getY) и сеттеры (setX и setY) с проверкой на ввод чисел, превышающих значение 1000000. Далее создаем конструкторы, чтобы создать 3 точки с разными координатами их потребуется 2: по умолчанию и с параметром. В конструкторе по умолчанию сразу задаем случайные значения, а во втором принимаем значение с сеттеров. Вывод через метод toString: выводим строку с координатами. В методе main создаем три точки и выводим их.
#### Пример вывода
1) Point(2,5); Point(-19, -1); Point()
Вывод: 
Точка 1: {2.0; 5.0}
Точка 2: {-19.0; -1.0}
Точка 3: {-5.0; 12.4}
2) Point(2,5); Point(-19, -1000500); Point()
Вывод: 
Точка 1: {2.0; 5.0}
-1000500 – слишком большое число! Будет установлено значение -10000
Точка 2: {-19.0; -10000.0}
Точка 3: {-5.0; 12.4}

# Задание 1
## Задача 3
### Текст задачи
Создайте сущность Имя, которая описывается тремя параметрами: Фамилия, Личное имя, Отчество. Имя может быть приведено к строковому виду, включающему традиционное представление всех трех параметров: Фамилия Имя Отчество (например “Иванов Иван Иванович”). Необходимо предусмотреть возможность того, что какой-либо из параметров может быть не задан, и в этом случае он не учитывается при приведении к текстовому виду. Необходимо создать следующие имена: 
• Клеопатра 
• Пушкин Александр Сергеевич
 • Маяковский Владимир 
Обратите внимание, что при выводе на экран, не заданные параметры никак не участвуют в образовании строки.
### Алгоритм решения
Создаем 3 приватных поля для фамилии, имени и отчества. Также прописываем свойства: геттеры и сеттеры (без проверок), а также конструкторы. Для того чтобы создавать разных личностей, прописываем 2 конструктора: по умолчанию и с параметром. В первом пусть создается имя «Клеопатра» (поля с фамилией и отчеством будут пустыми). Во второй передаем все 3 поля. Для того чтобы вывести строку (toString) при условии, что не заданные параметры не должны в ней находится, смотрим, если фамилия прописана, то добавляем ее к строке, если имя или отчество прописаны, но формируемая строка уже не пуста, то необходимо добавить место после предыдущего поля, иначе добавляем к строке данное поле. В main создаем 3 человек и выводим их.
 #### Пример вывода
1) Name(); Name(“Пушкин”, ”Александр”, ”Сергеевич”); Name(“Маяковский”, “Владимир”);
Вывод: 
Клеопатра
Пушкин Александр Сергеевич
Маяковский Владимир
2) Name(“Александр ”, ”Сергеевич”); Name(“Владимир”); Name();
Вывод:
Александр Сергеевич
Владимир
Клеопатра

# Задание 2
## Задача 1
### Текст задачи
Создайте сущность Линия, расположенную на двумерной плоскости, которая описывается:
 • Координата начала: Точка 
• Координата конца: Точка
 • Может возвращать текстовое представление вида “Линия от {X1;Y1} до {X2;Y2}”
 Для указания координат нужно использовать сущность Точка, разработанную в задании 1.1. Создайте линии со следующими характеристиками: 
1. Линия 1 с началом в т. {1;3} и концом в т.{23;8}.
 2. Линия 2, горизонтальная, на высоте 10, от точки 5 до точки 25.
 3. Линия 3, которая начинается всегда там же, где начинается линия 1, и заканчивается всегда там же, где заканчивается линия 2. Таким образом, если положение первой или второй линии меняется, то меняется и третья линия.
 4. После создания всех трех объектов измените координаты первой и второй линий, причем сделайте это таким образом, чтобы положение третьей линии соответствовало требованиям пункта 3. 
5. Измените координаты первой линии так, чтобы при этом не изменились, координаты третьей линии.
### Алгоритм решения
Создаем 2 приватных поля: точка начала и точка конца линии, используя сущность Point из 1 задачи. Прописываем свойства: геттеры и сеттеры (уже с проверкой на числа). Чтобы создавать разные линии сделаем 3 конструктора: по умолчанию, обычный с параметром и с параметром для горизонтальной линии (можно будет дважды координату y не вводить, и линия точно будет горизонтальной). В первом сразу создадим две новые точки и присвоим значениям начала и конца линии. Во второй передаем поля начала и конца, а в третий передаем по отдельности координаты x обеих точек и y, который будет одинаковый, в нем создаем снова две новые точки. В методе toString просто возвращаем строку с точками линии. В main создаем три линии, 3 из которых получает (getStart) для своей точки начала точку начала первой созданной линии, а для точки конца – точку конца 2 линии (getEnd). Для наглядности выводим все линии на экран до их изменений. Далее по условию меняем абсолютно все координаты точек 1 и 2 линии, выводим изменившиеся линии. Чтобы 3 линия не поменялась, когда поменяется 1 линия, необходимо для нее создать новые точки с новыми координатами и тогда заменить их. Снова выводим все линии.
   #### Пример вывода
1) Line(), Line(5,25,10), Line(line1.getStart(), line2.getEnd())
Вывод: 
Линия 1: Линия от {1.0;3.0} до {23.0;8.0}
Линия 2: Линия от {5.0;10.0} до {25.0;10.0}
Линия 3: Линия от {1.0;3.0} до {25.0;10.0}
2) line1.getStart().setX(15);
line1.getStart().setY(-3);
line1.getEnd().setX(1);
line1.getEnd().setY(4);
line2.getStart().setX(-10);
line2.getStart().setY(0);
line2.getEnd().setX(-5);
line2.getEnd().setY(0);
Вывод:
Линия 1: Линия от {15.0; -3.0} до {1.0; 4.0}
Линия 2: Линия от {-10.0;0.0} до {-5.0;0.0}
Линия 3: Линия от {15.0;-3.0} до {-5.0;0.0}
3) newStart = new Point(5, 2);
Point newEnd = new Point(8, 3);
Вывод:
Линия 1: Линия от {5.0; 2.0} до {8.0; 3.0}
Линия 2: Линия от {-10.0; 0.0} до {-5.0; 0.0}
Линия 3: Линия от {15.0;  -3.0} до {-5.0; 0.0}

# Задание 3
## Задача 3
### Текст задачи
Создайте сущность Город, которая будет представлять собой точку на карте со следующими характеристиками: 
• Название города
 • Набор путей к следующим городам, где путь представляет собой сочетание Города и стоимости поездки в него. 
Кроме того, Город может возвращать текстовое представление, в виде названия города и списка связанных с ним городов (в виде пары: “название: стоимость”). Используя разработанную сущность реализуйте схему, представленную на рисунке 2.
### Алгоритм решения
Создаем 2 приватных поля: название города и интерфейс Map, хранящий набор путей (Город: цена до него) к следующим городам. Прописываем геттеры и сеттеры для названия и Map, а также для стоимости (геттер). Далее прописываем конструктор, который принимает название города, в нем инициализируем его и создаем реализацию Map (пустую карту): HashMap, с помощью нее можно быстро добавлять и искать элементы, однако она не гарантирует порядок (сортировку). Далее создаем метод, который будет добавлять город маршрута и стоимость в Map. В нем делаем проверку на стоимость, чтобы она не была отрицательной, и добавляем путь. В методе toString выводим информацию в текстовом виде. В методе main создаем города, которые находятся в схеме №2, а потом добавляем для каждого город маршрута и стоимость поездки в него. Далее просто выводим на экран.
#### Пример вывода
1) City a = new City("A");
City b = new City("B");
City c = new City("C");
a.addRoute("B", 5);
a.addRoute("D", 6);

b.addRoute("A", 5);
b.addRoute("C", 3);

c.addRoute("B", 3);
Вывод:
A: {B=5, D=6}
B: {A=5, C=3}
C: {B=3}
2) City a = new City("A");
City b = new City("B");
City c = new City("C");
a.addRoute("B", -5);
a.addRoute("D", 6);

b.addRoute("A", 5);
b.addRoute("C", 3);

c.addRoute("B", 3);
Вывод:
Стоимость не может быть меньше или равной 0. Установлено значение 1
Схема на рисунке 2: 
A: {B=1, D=6}
B: {A=5, C=3}
C: {B=3}


# Задание 4
## Задача 8
### Текст задачи
Измените сущность Город из задачи 3.3. Новые требования включают:
 • Город можно создать, указав только название 
• Город можно создать, указав название и набор связанных с ним городов и стоимостей путей к ним
### Алгоритм решения
Решение все то же самое, только по условию задачи необходимо реализовать 2 конструктора: только с названием города и еще с набором путей. Первый такой же, как и в предыдущей задаче, а второй принимает уже не только название города, но и карту путей, далее устанавливаем название города, а в HashMap передаем все пары, находящиеся в Map, что сразу позволит прописывать маршруты и стоимость. Также необходимо проверить стоимость. Для этого проходим по всем парам Город: стоимость в карте, получаем ключ и значение, и проверяем его. Дальше просто добавляем маршрут в карту. Методы добавления маршрута и toString остаются такими же. В main некоторые города создадим с помощью 1 конструктора, а некоторые – 2. Для 2 конструктора создаем новую пустую карту HashMap, далее добавляем город и стоимость необходимые, и только тогда создаем город.
#### Пример вывода
1) City A = new City("A");
A.addRoute("B", 5);
A.addRoute("D", 6);

Map<String, Integer> bWay = new HashMap<>();
bWay.put("A", 5);
bWay.put("C", 3);
City B = new City("B", bWay);

Map<String, Integer> cWay = new HashMap<>();
cWay.put("B", 3);
cWay.put("D", 4);
City C = new City("C", cWay);

City D = new City("D");
D.addRoute("C", 4);
D.addRoute("E", 2);
D.addRoute("A", 6);

Вывод:
A: {B=5, D=6, F=1}
B: {A=5, C=3}
C: {D=4, B=3}
D: {A=6, C=4, E=2}
2) City A = new City("A");
A.addRoute("B", 5);
A.addRoute("D", 6);

Map<String, Integer> bWay = new HashMap<>();
bWay.put("A", -5);
bWay.put("C", 3);
City B = new City("B", bWay);

Map<String, Integer> cWay = new HashMap<>();
cWay.put("B", 3);
cWay.put("D", 4);
City C = new City("C", cWay);

City D = new City("D");
D.addRoute("C", 4);
D.addRoute("E", 2);
D.addRoute("A", 6);
Вывод:
Стоимость не может быть меньше или равной 0. Установлено значение 1
A:{B=5, D=6, F=1}
B:{A=1, C=3}
C:{D=4, B=3}
D:{A=6, C=4, E=2}

# Задание 5
## Задача 5
### Текст задачи
Создайте сущность Дробь со следующими особенностями: 
• Имеет числитель: целое число
 • Имеет знаменатель: целое число 
• Дробь может быть создана с указанием числителя и знаменателя 
• Может вернуть строковое представление вида “числитель/знаменатель” 
• Может выполнять операции сложения, вычитания, умножения и деления с другой Дробью или целым числом. Результатом операции должна быть новая Дробь (таким образом,обе исходные дроби не изменяются)
Затем необходимо выполнить следующие задачи: 
1. Создать несколько экземпляров дробей.
2. Написать по одному примеру использования каждого метода. 
3. Вывести на экран примеры и результаты их выполнения в формате «1/3 * 2/3 = 2/9» 
4. Посчитать f1.sum(f2).div(f3).minus(5)
### Алгоритм решения
Создаем 2 приватных поля: числитель и знаменатель. Прописываем для них свойства: геттеры и сеттеры (с проверкой на то, что знаменатель не может быть равен 0). Чтобы в ответе была наиболее простая дробь, создаем метод для их упрощения, для которого необходимо создать еще один метод. Этот метод будет искать наибольший общий делитель (число на которое поделится числитель и знаменатель). Соответственно в 1 методе это действие и будет выполняться. Далее создаем конструкторы, можно сделать всего 2: по условию и с параметром. В 1 сразу задаем дробь необходимую по условию, а во 2 передаем числитель и знаменатель и упрощаем дробь. Далее, так как по условию операции с дробью могут выполняться не только с другими дробями, но и с числами, то пропишем методы и для них. Всего получается 8 методов. В методах с дробями передаем объект сущности Дробь, а в методах с целыми числами передаем число. В методе toString выводим дробь в текстовом виде. В main создаем 4 дроби и выводим их на экран, потом выводим пример решения каждого созданного метода. В конце демонстрируем вывод ответа выражения данного по условию задачи, с пошаговым решением. 
#### Пример вывода
1) new Fraction();
Fraction fraction2 = new Fraction(-2, 3);
Fraction fraction3 = new Fraction(1, 4);
Fraction fraction4 = new Fraction(0, 5);
Вывод: 
Созданные дроби: 
f1 = 1/3
f2 = -2/3
f3 = 1/4
f4 = 0

Примеры выполнения операций: 
1/3 + -2/3 = -1/3
1/4 - 0 = 1/4
1/3 * 1/4 = 1/12

Знаменатель не может быть равен 0. Установлен знаменатель = 1
-2/3 / 0 = -2
1/3 + 3 = 10/3
-2/3 - 4 = -14/3
1/4 * 8 = 2
0 / 2 = 0

Вычисление выражения f1.sum(f2).div(f3).minus(5)
1/3 + -2/3 = -1/3
-1/3 / 1/4 = -4/3
-4/3 - 5  = -19/3
Результат: -19/3

2) new Fraction();
Fraction fraction2 = new Fraction(2, 3);
Fraction fraction3 = new Fraction(5, 8);
Fraction fraction4 = new Fraction(2, 7);
Вывод: 
Созданные дроби: 
f1 = 1/3
f2 = 2/3
f3 = 5/8
f4 = 2/7

Примеры выполнения операций: 
1/3 + 2/3 = 1
5/8 - 2/7 = 19/56
1/3 * 5/8 = 5/24
2/3 / 2/7 = 7/3
1/3 + 3 = 10/3
2/3 - 4 = -10/3
5/8 * 8 = 5
2/7 / 2 = 1/7

Вычисление выражения f1.sum(f2).div(f3).minus(5)
1/3 + 2/3 = 1
1 / 5/8 = 8/5
8/5 - 5  = -17/5
Результат: -17/5
